import java.util.*;import javax.xml.transform.*;import javax.xml.validation.*;import javax.xml.transform.stream.StreamResult;import javax.xml.transform.stream.StreamSource;import javax.xml.transform.dom.*;import javax.xml.transform.sax.*;import javax.xml.parsers.*;import java.util.regex.*;import java.net.URL;import org.xml.sax.*;import org.xml.sax.helpers.*;import org.w3c.dom.*;import org.apache.xerces.jaxp.validation.*;//import org.apache.xerces.parsers.SAXParser;import java.io.*;import javax.jnlp.*;public class SemVal {        private FileContents localXMLFC;        private InputStream localXMLIS;        private InputStream localXMLIS2;        private long xmlBytes;        private String fileNameOnlyXml;        private String urlXSD;        public boolean synValid = false;        private Vector <String> errors;        private Vector <String> warnings;                private TreeSet<Long> allIds;        private Hashtable <String, Vector<Long>> typeIds;        private Hashtable <String, Hashtable<Vector<Object>,Long>> links;        private Hashtable <String, Long> plBlanks;        public static final int maxErrors=10;        public static final int maxWarnings=10;        public SemVal(String localXML, String urlXSD) {                File myfile = new File(localXML);                this.fileNameOnlyXml=getFileNameOnly(localXML);                checkNamingConvention();                try {                        this.xmlBytes = myfile.length();                        this.localXMLIS = new FileInputStream(myfile);                        this.localXMLIS2 = new FileInputStream(myfile);                } catch (Exception e) {                        System.out.println(e.getMessage());                        output(e.getMessage());                }                this.urlXSD = urlXSD;                this.allIds = new TreeSet<Long>();                //System.out.println("Object created");        }        public SemVal(FileContents localXMLFC, String urlXSD) {                try {                        this.localXMLFC=localXMLFC;                        this.localXMLIS = localXMLFC.getInputStream();                        this.localXMLIS2 = null;                        this.urlXSD = urlXSD;                        this.xmlBytes = localXMLFC.getLength();                } catch (Exception e) {                        System.out.println(e.getMessage());                        output(e.getMessage());                }        }        private void checkNamingConvention() {                Pattern p = Pattern.compile("vipFeed-(\\d+)-(\\d\\d\\d\\d-\\d\\d-\\d\\d)");                Matcher m = p.matcher(this.fileNameOnlyXml);                if (m.matches()) {                        output("\nFile name passed: FIPS code " + m.group(1) + " with an election on " + m.group(2) + ".\n");                } else {                        output("Warning: your file does not meet the current naming convention of vipFeed-[FIPS]-[yyyy]-[mm]-[dd] where the date is the date of the election.");                }        }                private String getFileNameOnly(String fullPath) {            String pathSeparator="/";            int dotLength=3;            if (fullPath.lastIndexOf("\\") > fullPath.lastIndexOf("/")) {                    pathSeparator="\\";            }            String lastThree=fullPath.substring(fullPath.length() - dotLength,fullPath.length());            if (!lastThree.equals("xml")) {                    output("Naming Convention Warning: Your file should end with the extension xml");                    dotLength = (fullPath.length() - fullPath.lastIndexOf("."));            } else {                dotLength=4;            }            int sep = fullPath.lastIndexOf(pathSeparator);            return fullPath.substring(sep + 1, fullPath.length() - dotLength);        }                public String validateSyntax() {                XMLSchemaFactory xmlSF = new XMLSchemaFactory();                String lngStr = "";                if (xmlBytes > (1024 * 1024)) {                        lngStr = Math.round(xmlBytes / (1024 * 1024)) +                                "MB";                } else if (xmlBytes > 1024) {                        lngStr = Math.round(xmlBytes / 1024) + "KB";                } else {                        lngStr = xmlBytes + " bytes";                }                output("Staring syntactic validation....");                output("Your XML file is " +                        lngStr + ".");                output("On test computers, files of size 500MB took about one minute.");                Schema xmlS = null;                try {                        URL schemaURL = new URL(urlXSD);                        xmlS = xmlSF.newSchema(schemaURL);                } catch (Exception e) {                        return(e.getMessage());                }                Validator myval = xmlS.newValidator();                InputSource myis = new InputSource(localXMLIS);                SAXSource myss = new SAXSource(myis);                SAXResult res = null;                try {                        res = new SAXResult();                        //System.out.println("start");                        myval.validate(myss, res);                        synValid = true;                        return("Syntactic Validation Passed!");                } catch (Exception e) {                        synValid=false;                        return(e.getMessage() + "\n" + res.toString());                }        }               public String validateSemantics() {                output("Starting Semantic Validation...this could take a while.");                XMLReader parser;                try {                                        //XMLReader parser = new SAXParser();                        SAXParserFactory factory = SAXParserFactory.newInstance();                        parser = factory.newSAXParser().getXMLReader();                        //System.out.println(parser.getProperty("http://apache.org/xml/properties/input-buffer-size"));                        //parser.setProperty("http://apache.org/xml/properties/input-buffer-size",new Integer(1));                        //System.out.println(parser.getProperty("http://apache.org/xml/properties/input-buffer-size"));                                                errors = new Vector < String > ();                        warnings = new Vector < String > ();                        plBlanks = new Hashtable <String, Long> ();                        typeIds = new Hashtable <String, Vector<Long>> ();                        links = new Hashtable <String, Hashtable<Vector<Object>,Long>>();                                                ContentHandler contentHandler =                                new VipContentHandler(this);                        //DefaultHandler dh = (DefaultHandler)contentHandler;                        parser.setContentHandler(contentHandler);                } catch (Exception e) {                        return("Caught pre-parse error: " + e.getMessage());                }                                        try {                        if (this.localXMLIS2==null) {                                //this.localXMLIS.close();                                //this.localXMLIS2=this.localXMLFC.getInputStream();                                //this.localXMLIS2=this.localXMLIS;                        }                        parser.parse(new InputSource(localXMLIS2));                } catch (Exception e) {                        return("Caught error on parse: " + e.getMessage());                }                                //report any errors                output("\n\n");                if (errors.size()>0 || warnings.size()>0) {                        output("Found " + errors.size() + " top-level error(s)." + (errors.size()==maxErrors ? "(Stopped after " + maxErrors + " errors.)" : ""));                        output("Found " + warnings.size() + " top-level warning(s)." + (warnings.size()==maxWarnings ? "(Stopped after " + maxWarnings + " warnings.)" : ""));                        //if (errors.size()>=SemVal.maxErrors) output("Displaying first " + SemVal.maxErrors +" errors below.");                        //for(int i =0; i<errors.size() && i< SemVal.maxErrors; i++) {                        //        int num=i+1;                        //        output("Error " + num + ": " + (String)errors.get(i));                       //}                        //output("Fix these error(s) first.\n");                }                                                //report ids                                                if(1==0) {                                for (Enumeration e = links.keys(); e.hasMoreElements() ;) {                                        String key = (String)e.nextElement();                                        Hashtable<Vector<Object>,Long> thisTypeLinks = links.get(key);                                        System.out.println("Found " + thisTypeLinks.size() + " links(s) of type " + key);                                }                        }                        //test individual subsets                        //boolean allGood=(errors.size()==0);                        boolean allGood=true;                        boolean perfect=false;                        boolean streetSegsGoodP=false;                        boolean splitPrec=false, streetSegsGoodPS=false;                        int precPoll= -1, splitPoll = -1;                                                if (allGood && (hasType("source"))) {                                if (((Vector)typeIds.get("source")).size()>1) {                                        output("Error: This feed has more than one source object.");                                        allGood=false;                                        perfect=false;                                }                        } else {                                output("Error: This feed has no source objects. Exactly one is required.");                                allGood=false;                                perfect=false;                        }                                                if (allGood && (hasType("election"))) {                                if (((Vector)typeIds.get("election")).size()>1) {                                        output("Error: This feed has more than one election object.");                                        allGood=false;                                        perfect=false;                                }                        } else {                                output("Error: This feed has no election objects. Exactly one is required.");                                allGood=false;                                perfect=false;                        }                                                                      if (allGood && (hasType("street_segment"))) {                                output("Checking semantics of Street Segments...");                                if(!hasType("precinct") && !hasType("precinct_split")) {                                        output("Error: You have street_segment elements but no precinct or precinct_split elements.");                                }                                streetSegsGoodP = checkLinkType("street_segment->precinct_id",true) > 0;                                streetSegsGoodPS = checkLinkType("street_segment->precinct_split_id",true) > 0;                                                                                        allGood=(streetSegsGoodP || streetSegsGoodPS);                                perfect=(streetSegsGoodP && streetSegsGoodPS);                                output("..." + (allGood ? (perfect ? "passed." : "passed with non-fatal errors.") : "failed."));                        } else {                                output("WARNING: This feed does not have street segments; subsequent checks may fail because of this.");                        }                        if (allGood && hasType("precinct_split")) {                                output("\nChecking semantics of Precinct Splits...");                                if(!hasType("precinct")) {                                        output("Error: You have precinct split elements but no precinct split elements.");                                }                                splitPrec = checkLinkType("precinct_split->precinct_id",true) > 0;                                splitPoll = checkLinkType("precinct_split->polling_location_id",true);                                                                allGood=splitPrec && (splitPoll>=0);                                perfect=splitPrec && (splitPoll>0);                                output("..." + (allGood ? (perfect ? "passed." : "passed with non-fatal errors.") : "failed."));                        }                        if (allGood && hasType("precinct")) {                                output("\nChecking semantics of Precincts...");                                if(!hasType("locality")) {                                        output("Error: You have precinct elements but no locality elements.");                                }                                boolean precLocal = checkLinkType("precinct->locality_id",true) > 0;                                precPoll = checkLinkType("precinct->polling_location_id",true);                                allGood=precLocal && (precPoll>=0);                                 perfect=precLocal && (precPoll>=0);                                output("..." + (allGood ? (perfect ? "passed." : "passed with non-fatal errors.") : "failed (make sure that the connection(s) from street segments to polling locations is/are valid)."));                        }                                                if (allGood && hasType("polling_location")) {                                output("\nChecking Semantics of Poll Locations...");                                if(!hasType("precinct") && !hasType("precinct_split")) {                                        output("Error: You have polling_location elements but no precinct or precinct_split elements.");                                }                                allGood=(streetSegsGoodP && (precPoll>0)) || (streetSegsGoodPS && (splitPoll>0)) ||                                        (streetSegsGoodPS && splitPrec && (precPoll>0));                                perfect=allGood;                                output("..." + (allGood ? (perfect ? "passed." : "passed with non-fatal errors.") : "failed."));                        } else if (!hasType("polling_location")) {                                output("WARNING: " + "This feed does not contain Polling Locations.");                        }                        if (allGood && hasType("electoral_district")) {                                output("\nChecking Semantics of Districts...");                                if(!hasType("precinct") && !hasType("precinct_split")) {                                        output("Error: You have electoral_district elements but no precinct or precinct_split elements.");                                }                                boolean precinctToED = checkLinkType("precinct->electoral_district_id",true) > 0;                                boolean splitToED = checkLinkType("precinct_split->electoral_district_id",true) > 0;                                allGood=(streetSegsGoodP && precinctToED)  || (streetSegsGoodPS && splitToED) ||                                         (streetSegsGoodPS && splitPrec && precinctToED);                                perfect = streetSegsGoodPS && splitPrec && precinctToED && splitToED;                                output("..." + (allGood ? (perfect ? "passed." : "passed with non-fatal errors.") : "failed."));                        }                        if (allGood && hasType("contest")) {                                output("\nChecking Semantics of Contests...");                                if(!hasType("electoral_district")) {                                        output("Error: You have contest elements but no electoral_district elements.");                                }                                if(!hasType("ballot")) {                                        output("Error: You have contest elements but no ballot elements.");                                }                                                                boolean contestToED = checkLinkType("contest->electoral_district_id",true) > 0;                                boolean contestToBallot = checkLinkType("contest->ballot_id",true) >= 0;                                allGood=contestToED && contestToBallot;                                perfect=contestToED && contestToBallot;                                output("..." + (allGood ? (perfect ? "passed." : "passed with non-fatal errors.") : "failed."));                        }                                          if (allGood && hasType("ballot")) {                                output("\nChecking Semantics of Ballots...");                                if(!hasType("candidate") && !hasType("referendum") && !hasType("custom_ballot")) {                                        output("Error: You have ballot elements but no candidate, referendu, or custom_ballot elements.");                                        allGood=false;                                }                                boolean ballotToCandidate = checkLinkType("ballot->candidate_id",true)  >= 0;                                boolean ballotToRefendum = checkLinkType("ballot->referendum_id",true) >= 0;                                boolean ballotToCustomBallot = checkLinkType("ballot->custom_ballot_id",true) >=0;                                allGood=allGood && ballotToCandidate && ballotToRefendum && ballotToCustomBallot;                                perfect=allGood;                                output("..." + (allGood ? (perfect ? "passed." : "passed with non-fatal errors.") : "failed."));                        }                                                if (allGood && hasType("locality")) {                                output("\nChecking Semantics of Locality...");                                if(!hasType("state")) {                                        output("Error: You have locality elements but no state element");                                        allGood=false;                                }                                boolean localityToState = checkLinkType("locality->state_id",true) > 0;                                if (hasType("election_administration")) {                                        int lea = checkLinkType("locality->election_administration_id",true);                                        boolean localityToAdministration = (lea >=0);                                        allGood=allGood && localityToAdministration;                                        if (lea==0) {                                               output("Consider adding Election Administrations for Localities for a better feed.");                                        }                                }                                else {                                        output("Consider adding Election Administrations for Localities for a better feed.");                                }                                allGood=allGood && localityToState;                                perfect=allGood;                                output("..." + (allGood ? (perfect ? "passed." : "passed with non-fatal errors.") : "failed."));                        }                        if (allGood && hasType("state")) {                                output("\nChecking Semantics of State...");                                boolean stateToAdministration = true;                                int sea=0;                                if (hasType("election_administration")) {                                        sea = checkLinkType("state->election_administration_id",true);                                        stateToAdministration = (sea >=0);                                        allGood=allGood && stateToAdministration;                                        if (sea==0) {                                               output("Consider adding Election Administrations for State for a better feed.");                                        }                                }                                else {                                        output("Consider adding Election Administrations for State for a better feed.");                                }                                allGood=allGood && stateToAdministration;                                perfect=allGood && (sea==1);                                output("..." + (allGood ? (perfect ? "passed." : "passed with non-fatal errors.") : "failed."));                        }                                                if (allGood && hasType("election_administration")) {                                output("\nChecking Semantics of Election Administration...");                                if (hasType("election_official")) {                                        boolean adminToOfficial = checkLinkType("election_administration->eo_id",true)>=0;                                        allGood=allGood && adminToOfficial;                                        boolean adminToOfficial2 = checkLinkType("election_administration->ovc_id",true)>=0;                                        allGood=allGood && adminToOfficial2;                                } else {                                        output("You should link election_administration objects to election_official objects via the eo_id element");                                }                                perfect=allGood;                                output("..." + (allGood ? (perfect ? "passed." : "passed with non-fatal errors.") : "failed."));                        }                        if (allGood && hasType("contest_result")) {                                output("\nChecking Semantics of Contest Results...");                                if(!hasType("contest")) {                                        output("Error: You have contest result elements but no contest elements.");                                }                                boolean contestResultToContest = checkLinkType("contest_result->contest_id",true) > 0;                                boolean contestResultToJurisdiction = checkLinkType("contest_result->jurisdiction_id",false) > 0;                                allGood=contestResultToContest && contestResultToJurisdiction;                                perfect=contestResultToContest && contestResultToJurisdiction;                                output("..." + (allGood ? (perfect ? "passed." : "passed with non-fatal errors.") : "failed."));                        }                                                  if (allGood && hasType("ballot_line_result")) {                                output("\nChecking Semantics of Ballot Line Results...");                                if(!hasType("contest")) {                                        output("Error: You have ballot line result elements but no contest elements.");                                }                                boolean lineResultToContest = checkLinkType("ballot_line_result->contest_id",true) > 0;                                boolean lineResultToJurisdiction = checkLinkType("ballot_line_result->jurisdiction_id",false) > 0;                                allGood=lineResultToContest && lineResultToJurisdiction;                                perfect=lineResultToContest && lineResultToJurisdiction;                                output("..." + (allGood ? (perfect ? "passed." : "passed with non-fatal errors.") : "failed."));                        }                                                                  String helpTypes="\n\nFYI, This feed includes the following (non-trivial) types:\n" + getTypesAsString();                        String locationInfo="";                        if (hasType("polling_location")) {                                String blankInfo=getBlankInfo();                                if (blankInfo.length()>0) {                                        locationInfo="\n\nOf the " + ((Vector)typeIds.get("polling_location")).size() + " polling locations:" + blankInfo;                                }                        }                        return("\nSemantic Validation " + ((allGood && errors.size()==0) ? "Passed!" : "Failed.") + helpTypes + locationInfo);        }        private String getTypesAsString() {                Object[] types=typeIds.keySet().toArray();                String retv="";                for(int i=0; i<types.length; i++) {                        retv=retv + types[i]+ " (" + ((Vector)typeIds.get(types[i])).size() + " element[s])\n";                }                return(retv);        }                private void output(String msg) {                if (!VipSemChecker.isAlive()) {                        System.out.println(msg);                } else {                        VipSemChecker.appendMessage(msg);                }        }        private boolean hasType(String typeKey) {                Vector<Long> allIdsOfType = typeIds.get(typeKey);                return  (allIdsOfType!=null  &&  (allIdsOfType.size()>0));        }                //does the feed have links of this type        private boolean hasLinkType(String typeKey) {                Hashtable<Vector<Object>,Long> thisTypeLinks = links.get(typeKey);                return(thisTypeLinks!=null);        }                private Vector<Object> findKeyForValue(Hashtable<Vector<Object>,Long> thisTypeLinks, Long needle) {                Iterator<Map.Entry<Vector<Object>,Long>> iter=thisTypeLinks.entrySet().iterator();                while(iter.hasNext()) {                        Map.Entry<Vector<Object>,Long> me = iter.next();                        if (me.getValue()==needle) {                                return(me.getKey());                        }                }                return(null);        }                //return 1 when links are present and good, 0 when links are not present, -1 for broken links        private int checkLinkType(String typeKey, boolean fixedType) {                Hashtable<Vector<Object>,Long> thisTypeLinks = links.get(typeKey);                if (thisTypeLinks!=null && thisTypeLinks.size()>0) {                        int numLinks=thisTypeLinks.size();                        Collection<Long> toIds = thisTypeLinks.values(); //Collection of Long                                                String toType = SemVal.getToType(typeKey,true);                        Collection allIdsOfType = null;                        if (fixedType) {                                allIdsOfType = typeIds.get(toType);                        } else {                                allIdsOfType = allIds;                        }                        try {                                if (allIdsOfType!=null) toIds.removeAll(allIdsOfType);                        } catch(Exception e) {                                System.out.println(e.getMessage());                        }                        String msg = "Relationship " + typeKey + " has " + numLinks + " link(s)";                        boolean retv= !(toIds!=null && toIds.size()>0);                        if (!retv) {                                int numMissLinks = toIds.size();                                msg += ", but includes " + numMissLinks + " missing link(s).\n";                                Iterator iterMiss = toIds.iterator();                                Long exId = (Long) iterMiss.next();                                Vector<Object> exV=findKeyForValue(thisTypeLinks,exId);                                if (exV==null) {                                        msg+="Program error: couldn't find key " + exId;                                } else {                                        Long fromId=(Long)exV.get(0);                                        Long lineNumber=(Long)exV.get(1);                                        msg +="Example of error: At line number " + lineNumber +                                         " you linked from ID " + fromId + " to ID " + exId + " but there is no object of type " + toType + " with that ID.";                                }                        } else {                                msg +=", and they look good.";                        }                        output(msg);                        return(retv ? 1 : -1);                } else {                        output("No links of type " + typeKey + " are present");                        return(0);                }        }                public void addIdType(Long id, String elType, int lineNumber) {                boolean newId = allIds.add(id);                if (!newId) {                     addError("Duplicate ID: " + id + " at line number " + lineNumber);                   } else {                        if (!typeIds.containsKey(elType)) {                                typeIds.put(elType,new Vector<Long>());                        }                        Vector<Long> v = typeIds.get(elType);                        v.add(id);                }        }        private static String concatLinkTypes(String fromType, String toType) {                return(fromType + "->" + toType);        }                private static String getToType(String concattedType, boolean dropIdPart) {                String[] retvA = concattedType.split("->");                String retv=retvA[1];                if (dropIdPart) {                        retv=retv.substring(0,retv.length()-3);                }                if (retv.equals("eo") || retv.equals("ovc")) retv="election_official";                return(retv);        }                public void addLink(String fromType, Long fromId, int lineNumber, String toType, Long toId) {                String linkType = SemVal.concatLinkTypes(fromType, toType);                if (!links.containsKey(linkType)) {                        links.put(linkType, new Hashtable<Vector<Object>,Long>());                }                Hashtable<Vector<Object>,Long> thisTypeLinks = links.get(linkType);                Vector<Object> tmp = new Vector<Object>();                tmp.add(fromId);                tmp.add(new Long(lineNumber));                thisTypeLinks.put(tmp, toId);        }        public void addError(String message) {                if(errors.size()<maxErrors) {                        errors.add(message);                        output("Error " + errors.size() + ": " + (String)errors.get(errors.size()-1));                }        }                public int getErrorCount() {                return(errors.size());        }        public void addWarning(String message) {                if(warnings.size()<maxErrors) {                        warnings.add(message);                        output("Warning " + warnings.size() + ": " + (String)warnings.get(warnings.size()-1));                }        }                public int getWarningCount() {                return(warnings.size());        }                public void addBlank(String elementName) {                if (!plBlanks.containsKey(elementName)) {                        plBlanks.put(elementName,new Long(1));                } else {                        Long cur=plBlanks.get(elementName);                        plBlanks.put(elementName,new Long(cur.longValue() + 1));                }        }        public long getBlank(String elementName) {                Long cur=plBlanks.get(elementName);                return (cur==null ? 0 : cur.longValue());        }                private String getBlankInfo() {                String retv="";                for (Enumeration keys = plBlanks.keys(); keys.hasMoreElements() ;) {                        String k = (String)(keys.nextElement());                        long numBlanks=plBlanks.get(k).longValue();                        retv=retv + "\n" + numBlanks + " " + k + " element(s) is/are blank";                }                return(retv);        }                public boolean isSynValid() {                return(synValid);        }        public static void main(String[] args) {                SemVal sv = new SemVal("D:/google/spec/vipFeed-39-2009-11-06.xml","file://localhost/D:/google/election-info-standard/vip_spec_v3.0.xsd");                //SemVal sv = new SemVal("D:/google/election-info-standard/sample feed for v2.2.xml","file://localhost/D:/google/election-info-standard/vip_spec_v2.2.xsd");                //SemVal sv = new SemVal("D:/google/state data/VA/2010/vipFeed-51-2010-05-19T16-04-00.xml","file://localhost/D:/google/spec/vip_spec_v2.1.xsd");                //SemVal sv = new SemVal("D:/google/state data/MT/vipFeed-30-2010-05-24T15-06-54.xml","file://localhost/D:/google/spec/vip_spec_v2.1.xsd");                //SemVal sv = new SemVal("D:/google/state data/CO/vipFeed-08-2010-07-19T15-19-28.xml","file://localhost/D:/google/spec/vip_spec_v2.1.xsd");                System.out.println(sv.validateSyntax());                System.out.println("\n\n");                System.out.println(sv.validateSemantics());        }}